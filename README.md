# Reflection

1. What are the key differences between unary, server streaming, and bi-directional streaming
RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable? \
> Perbedaan utama antara metode RPC unary, server streaming, dan bi-directional streaming terletak pada pola komunikasi data antara klien dan server. Pada RPC unary, klien mengirim satu permintaan dan menerima satu respons yang cocok untuk operasi sederhana seperti autentikasi atau permintaan data tunggal. Server streaming memungkinkan klien mengirim satu permintaan, tetapi server merespons dengan aliran data bertahap. Approach ini ideal untuk mengirim banyak data secara bertahap seperti hasil pencarian besar atau notifikasi berkala. Sementara itu, bi-directional streaming memungkinkan klien dan server saling mengirim data secara bersamaan dan terus menerus, menjadikannya cocok untuk aplikasi real-time seperti obrolan langsung, monitor sensor, atau layanan konferensi video. Pemilihan metode tergantung pada kebutuhan komunikasi data dalam aplikasi.

2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
> Menurut saya terdapat beberapa pertimbangan keamanan penting yang perlu diperhatikan, khususnya terkait autentikasi, otorisasi, dan enkripsi data. Pertama, autentikasi harus memastikan bahwa hanya klien yang sah dapat mengakses layanan, yang bisa dilakukan dengan TLS mutual authentication atau integrasi dengan token berbasis OAuth2/JWT. Kedua, otorisasi perlu diterapkan setelah autentikasi untuk membatasi akses pengguna berdasarkan peran atau hak akses tertentu, yang bisa disisipkan ke dalam interceptor gRPC. Ketiga, enkripsi data sangat krusial, komunikasi antar klien dan server harus menggunakan TLS (Transport Layer Security) agar data tidak bisa disadap atau dimodifikasi oleh pihak ketiga. Selain itu, Rust memiliki keunggulan dalam mencegah banyak bug memori seperti buffer overflows, namun pengembang tetap harus waspada terhadap race conditions, dependensi yang tidak aman, serta harus menghindari hardcoded secrets dalam kode. Pemindaian keamanan, audit crate pihak ketiga, dan penggunaan sandboxing (jika diperlukan) juga merupakan praktik baik dalam menjaga keamanan layanan gRPC di Rust.\
src: [Security considerations in gRPC](https://learn.microsoft.com/en-us/aspnet/core/grpc/security?view=aspnetcore-9.0)


3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
> Menangani bidirectional streaming dalam Rust gRPC, terutama pada skenario seperti aplikasi chat, dapat memunculkan sejumlah tantangan teknis yang signifikan. Pertama, sinkronisasi dan pengelolaan state antara banyak klien dan server secara bersamaan menjadi rumit, karena Rust sangat ketat soal ownership dan borrow checker—hal ini membuat manajemen state bersama (shared state) membutuhkan pendekatan hati-hati, misalnya menggunakan `Arc<Mutex<>>` atau `tokio::sync primitive`s. Kedua, handling concurrent streams memerlukan pengelolaan asynchronous yang efisien, di mana kesalahan kecil dalam penanganan task async bisa menyebabkan deadlock atau starvation. Ketiga, error handling dan stream termination harus ditangani eksplisit—misalnya jika satu sisi memutus koneksi, server harus dapat menutup stream dengan bersih agar tidak terjadi memory leak atau dangling tasks. Terakhir, backpressure dan flow control juga penting, bila satu pihak mengirim pesan terlalu cepat sementara pihak lain lambat membaca, sistem bisa mengalami bottleneck. Rust memberikan kontrol sangat baik atas hal-hal tersebut, tapi sekaligus membuat implementasinya lebih kompleks dibanding bahasa dengan garbage collector dan async model yang lebih longgar seperti Go atau Node.js.

4. What are the advantages and disadvantages of using the
tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
> Menggunakan `tokio_stream::wrappers::ReceiverStream` dalam layanan gRPC Rust memiliki kelebihan dan kekurangan yang perlu dipertimbangkan. Keunggulannya, `ReceiverStream` memungkinkan integrasi yang mudah antara channel `tokio::mpsc` dan stream gRPC, sehingga kita dapat mengirim data dari thread atau task lain secara asynchronous ke dalam stream gRPC secara natural dan efisien. Approach ini sangat berguna dalam skenario seperti streaming data real-time atau notifikasi, karena memisahkan logika penghasil data dari mekanisme pengiriman. Namun, kelemahannya adalah kontrol aliran (flow control) yang kurang eksplisit, jika producer mengirim data terlalu cepat, dan consumer lambat memproses, bisa menyebabkan penumpukan pesan atau bahkan kehabisan buffer, terutama jika tidak dikonfigurasi dengan baik. Selain itu, debugging aliran data bisa menjadi lebih kompleks karena adanya concurrency, terutama saat menangani error atau saat stream ditutup lebih awal.

5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity,
promoting maintainability and extensibility over time?
> Untuk memfasilitasi reuse dan modularitas dalam kode Rust gRPC, struktur proyek sebaiknya diorganisasi secara jelas dan terpisah antara berbagai komponen utama. Pertama, proto files dapat diletakkan dalam folder khusus (`proto/`) dan hasil kompilasi .rs-nya ditempatkan di modul tersendiri (`mod.rs`atau `generated/`). Kedua, pisahkan logika bisnis dari implementasi gRPC dengan membuat lapisan service handler (misalnya s`ervices/`) yang hanya berisi logika core aplikasi. Ketiga, gunakan trait untuk mendefinisikan antarmuka abstrak dari layanan agar bisa diuji atau diganti implementasinya dengan mudah. Keempat, kelompokkan konfigurasi, inisialisasi, dan utilitas umum di modul khusus seperti `config/` atau `utils/`. Dengan pendekatan modular ini, kode akan lebih mudah dimaintain, diuji unit secara terpisah, dan diperluas (misalnya menambah endpoint atau service baru) tanpa harus mengubah banyak bagian kode yang sudah ada.

6. In the MyPaymentService implementation, what additional steps might be necessary to
handle more complex payment processing logic?
> Untuk menangani logika pemrosesan pembayaran yang lebih kompleks dalam `MyPaymentService`, langkah-langkah tambahan yang perlu dilakukan antara lain mengintegrasikan sistem dengan penyedia layanan pembayaran eksternal seperti Stripe atau PayPal, serta menambahkan validasi dan otentikasi pengguna untuk memastikan keabsahan pembayaran. Selain itu, penanganan kesalahan dan transaksi rollback sangat penting agar jika terjadi kegagalan, seluruh proses dapat dibatalkan tanpa merusak integritas data. Pemrosesan pembayaran asinkron juga diperlukan agar tidak memblokir proses lain, sementara pencatatan transaksi untuk audit log dan pengamanan data pengguna melalui enkripsi akan menjaga keamanan dan kepatuhan sistem. Terakhir, pemberitahuan kepada pengguna mengenai status transaksi melalui saluran komunikasi seperti email atau SMS juga perlu dipertimbangkan.

7. What impact does the adoption of gRPC as a communication protocol have on the overall
architecture and design of distributed systems, particularly in terms of interoperability with
other technologies and platforms?
> Adoption of gRPC sebagai protokol komunikasi berdampak signifikan terhadap arsitektur sistem terdistribusi karena menyediakan komunikasi yang efisien, cepat, dan berbasis HTTP/2 dengan dukungan streaming dan kontrak eksplisit melalui Protobuf. Ini mendorong desain sistem berbasis layanan (microservices) yang lebih konsisten dan terstruktur. Namun, dari sisi interoperabilitas, meskipun gRPC mendukung berbagai bahasa pemrograman, integrasi dengan sistem yang tidak mendukung HTTP/2 atau Protobuf secara langsung (seperti browser tanpa proxy, sistem warisan, atau REST-only API) bisa menjadi tantangan dan memerlukan adaptasi tambahan seperti gateway REST (contoh: grpc-gateway) atau konversi format data.

8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for
gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
> Keuntungan utama menggunakan HTTP/2 untuk gRPC dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket adalah kemampuannya untuk menangani multiplexing, yang memungkinkan beberapa permintaan dan respons diproses secara paralel melalui satu koneksi TCP, mengurangi latensi dan overhead yang terkait dengan pembuatan banyak koneksi. Selain itu, HTTP/2 mendukung kompresi header dan pengalihan prioritas permintaan, yang meningkatkan efisiensi dan performa. Namun, kekurangannya adalah bahwa HTTP/2 lebih kompleks dalam pengimplementasiannya dan tidak selalu didukung oleh semua browser atau infrastruktur yang lebih tua. Sementara WebSocket pada HTTP/1.1 menawarkan komunikasi dua arah real-time, HTTP/2 menawarkan keunggulan lebih dalam hal skalabilitas dan pengelolaan koneksi, meskipun memerlukan dukungan dari server dan client yang lebih modern.

9. How does the request-response model of REST APIs contrast with the bidirectional streaming
capabilities of gRPC in terms of real-time communication and responsiveness?
> Model request-response pada REST API berbeda dengan kemampuan streaming dua arah pada gRPC dalam hal komunikasi real-time dan responsivitas. Pada REST API, komunikasi dilakukan secara request-response di mana klien mengirimkan permintaan ke server dan menunggu respons. Setiap permintaan memerlukan koneksi terpisah dan server hanya merespons setelah menerima dan memproses permintaan tersebut, yang bisa menambah latensi, terutama dalam kasus komunikasi yang memerlukan interaksi berkelanjutan atau real-time. Sebaliknya, gRPC dengan streaming dua arah memungkinkan komunikasi yang lebih efisien dan responsif, karena klien dan server dapat saling mengirim dan menerima data secara terus-menerus melalui satu koneksi yang dipertahankan. Ini sangat cocok untuk aplikasi real-time seperti chat atau game online, di mana data dikirimkan secara terus-menerus dan respons diberikan hampir seketika tanpa perlu menunggu permintaan baru dari klien.

10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers,
compared to the more flexible, schema-less nature of JSON in REST API payloads?
> Approach berbasis skema gRPC menggunakan Protocol Buffers memiliki beberapa implikasi signifikan dibandingkan dengan sifat JSON yang lebih fleksibel dan tanpa skema pada payload REST API. Pertama, penggunaan Protocol Buffers pada gRPC memastikan struktur data yang lebih ketat dan konsisten, yang mempermudah validasi dan parsing data, serta meningkatkan performa karena data yang dikirimkan lebih ringkas dan terkompresi. Hal ini membuat gRPC lebih efisien untuk komunikasi antar layanan dalam sistem terdistribusi yang kompleks. Di sisi lain, JSON dalam REST API bersifat lebih fleksibel karena tidak membutuhkan definisi skema yang ketat, memungkinkan pengembangan yang lebih cepat dan perubahan payload yang lebih mudah. Namun, fleksibilitas ini bisa menyebabkan potensi ketidakcocokan data antara klien dan server, serta membuat parsing dan validasi data lebih rawan kesalahan. Secara keseluruhan, gRPC dengan skema lebih cocok untuk aplikasi dengan kebutuhan performa tinggi dan integritas data, sementara REST API lebih cocok untuk aplikasi dengan evolusi payload yang dinamis dan pengembangan cepat.